// https://www.bilibili.com/video/BV1PD4y1o7nd/?spm_id_from=333.788
// https://www.bilibili.com/video/BV1M5411j7Xx/?spm_id_from=333.788
// KMP算法核心思想就是一个对称性!你不是当前位置的字符不匹配吗,你虽然当前位置这一个字符不匹配,但是我知道的信息是你模式串里面这个字符之前所有的字符都匹配了
// 例如：
//      主串：  [X][...][X][p][...] 
//      模式串：[X][...][X][s]      [s]和[p]代表没有匹配成功的当前字符，[X]是一个子串，你看你[s]和[p]虽然没有匹配，但是我知道的信息是：[X][...][X]这肯定都匹配了对吧！
// 那么我可以聪明一点,我再给你一次匹配的机会!我把模式串的前缀[X]移动到和主串第二个[X]对齐!变成:
//      主串：  [X][...][X][p][...] 
//      模式串：        [X][...][X][s]  这种情况,那么我就继续比较主串中的[p][...]是否和模式串中的[...][X][s]匹配即可!
// 其实主要就是运用了一个模式串自身有一定的对称性!那么我遇到了不匹配的字符了,我可以"再给你一次机会",看看把模式串的前缀和主串的后缀对齐了,是否接下来能匹配.
class Solution {
public:
    // 很容易发现其实寻找next数组的过程和主程序匹配字符串的过程基本一致!因为寻找next数组的过程其实就是模式串自己和自己匹配的过程!
    // 即: 将模式串的前缀当成模式串,将模式串的后缀当成主串 (这一点在这里讲的很好:https://www.bilibili.com/video/BV1234y1y7pm/?spm_id_from=333.788&vd_source=dabcffd1cd0c95a73e0d13f61da7ae44)
    void getNext(int* next, string& s){
        next[0] = 0;
        int j = 0;
        // 用i定位主串(即模式串的后缀)
        for (int i = 1; i < s.size(); i++){
            // 当前在字符不匹配的情况，一直回溯，直到相同或者j为1.
            while (j - 1 >= 0 && s[j] != s[i]){
                // 回溯j,这里其实和主程序的回溯思路一样!这里就是在把模式串的前缀(用j定位)当作模式串,模式串的后缀(用i定位)当作主串,所以我们发现了不相同的字符,我们回溯模式串(即模式串的前缀).
                // 这里还要注意这个next数组的定义方式,我选择了最传统却不是最直接的,即:next[j]代表了字符串从头到j位置的子串的最长相同前后缀, 这样的话我们回溯的位置是s位置下标之前的next数组的值。
                // 忘了的话就去参考一下代码随想录b站视频这一题的讲解.
                // 用于定位模式串的j指向的是前缀的末尾，用于定位主串的i指向的是后缀的末尾。
                j = next[j - 1];
            }
            // 当前字符匹配成功的情况，那么将j(指向前缀末尾，数值其实等于(前缀长度 - 1))移动 (i本身就在循环体内，所以每次自己就在移动了。)
            if (s[j] == s[i]){
                j++;
            }
            // 当前位置next的值
            // 整体看下来的话其实就可以发现next数组的构建过程是一个不断迭代的过程， 即：这里我们的目的是想得到next数组，但是我们却用到了next的值（体现在j = next[j - 1]这一行代码）。
            //     ------> "我的终点是拯救你,可是起点却是你的死亡."  --<<异度侵入ID:invaded>>
            next[i] = j;
        }
    }
    // 主程序的匹配过程，用到了模式串的前后缀对称性质，其实就是和构建next数组的过程一!模!一!样!毕竟构建next数组的过程其实就是把模式串的前缀当成模式串，模式串的后缀当成主串进行匹配。
    int strStr(string haystack, string needle) {
        int next[needle.size()];
        int j = 0;
        // 构建模式串的next数组。
        getNext(next, needle);
        // 这里和构建next数组时候有一个不一样的地方在于这里要从0开始，构建next数组里面我们i从1开始是因为我们是考虑的主串和模式串（即模式串的后缀和前缀）在同一个字符串内，这里我们的主串和模式串是两个完全分开的字符串。
        for (int i = 0; i < haystack.size(); i++){
            // 当前字符不匹配的情况，根据next数组回溯，你看，是不是和构建next数组的时候一模一样？
            while (j - 1 >= 0 && haystack[i] != needle[j]){
                j = next[j - 1];
            }
            if(haystack[i] == needle[j]){
                j++;
            }
            // 和构建next数组时候唯一的不同就在于这里的操作，我们上面运用前后缀对称性的性质是为了更新并且最后得到next数组，这里我们运用这个性质是为了匹配字符串.
            // j++之后等于了模式串的长度,说明模式串内的字符已经全部匹配完毕,因为j是从0开始的,j++等于模式串长度,说明之前最后匹配到的j位置已经是模式串最后一个字符位置了.
            if (j == needle.size()){
                // 记住我们是用i定位主串的，这一点在匹配主程序和构建next函数里面都是一样的。
                // i一直在和j一起走！所以如果j走到了模式串的最后一位的后一位（因为++了），那么说明主串里面的i也走到了主串里存在的模式串的最后一位字符。
                // 但是要注意一下这里的判断逻辑，因为j是直接++了，但是因为i是在for循环体里面，所以此时还没有++,即此时如果考虑主串里面的模式串相对位置，那么j要比i大1（主串里模式串的相对位置！！）。
                return (i - needle.size() + 1);
            }
        }
        return -1;
    }
};


